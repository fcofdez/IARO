#include "RayTracer.hpp"
 
RayTracer::RayTracer(std::vector<Triangle *> meshData)
{
  __objects = meshData;
  __bvh = Bvh(__objects);
  LightSource  light;
  light.name = "lamparica";
  light.location = Vector(4.1,1,5.9);
  light.vDirection = Vector(1,0,0);
  light.energy = 1.0;
  light.lampType = LAMP;
  __lightSources.push_back(&light);
}

RayTracer::~RayTracer()
{}


Vector
RayTracer::Trace(Ray *ray)
{
  Vector Pos;

  __bvh.TestIntersection(ray);

  if (ray->GetNearestObject() != NULL)
    Pos = ray->GetOrigin() + ray->GetDirection() * ray->GetNearestHitDistance();
  else
    Pos.Set(MAX_DISTANCE, MAX_DISTANCE, MAX_DISTANCE);
      
  return Pos;
}

Ray
RayTracer::castRay(LightSource * ls)
{
  Vector lampVNormal = ls->vDirection;
  Ray rayToCast;

  bool cast = false;

  while (!cast)
    {
      double x = ((double)rand() / (double)RAND_MAX);
      double y = ((double)rand() / (double)RAND_MAX);
      double z = ((double)rand() / (double)RAND_MAX);
      
      int die = rand() % 2;
      if (die == 1) x *= -1;
      die = rand() % 2;
      if (die == 1) y *= -1;
      die = rand() % 2;
      if (die == 1) z *= -1;
      
      Vector dir(x, y, z);

      if (dir.Length() <= 1.0) //Unit Sphere
        {
          if (ls->lampType == LAMP)
            {
              rayToCast.SetOrigin(ls->location);
              rayToCast.SetDirection(dir);
              cast = true;
            }
          else
            {
              if (lampVNormal.DotProduct(dir) >= 0.0f) //Rays unnecesary
                {
                  rayToCast.SetOrigin(ls->location);
                  rayToCast.SetDirection(dir);
                  cast = true;
                }
            }
        }
    }

  return rayToCast;
}

bool
RayTracer::RayTrace(bool indoorLightSources)
{

  std::vector<LightSource *>::iterator lamp;

  for (lamp = __lightSources.begin() ; lamp != __lightSources.end() ; lamp++)
    {
      int nonNullIntersectPoints = 0;
      int nonVisible = 0;
      int didntHit = 0;
      
      for (unsigned int r = 0; r < RAYS_TO_TRACE ; r++)
        {
          Ray ray = castRay((*lamp));
          Vector pInt = Trace(&ray);
          if (ray.GetNearestObject() != NULL)
            {
              Triangle *hitSurface = (Triangle *)ray.GetNearestObject();
              nonNullIntersectPoints += 1;
              double whiteLevel = 0; //FIX
              double pDistToLam = 0; //FIX
            }
          else
            didntHit += 1;
        }
    }
  return true;
}
